[인포뱅크] 조기성 연구원 (모비스 담당자 : [CCU AP SW셀] 성기영 책임)

1. 이슈로 잡힌 이유 :
평가 순서가 정해지지 않은 인수에 다수의 변수 호출

2. 정당화 사유 :
각 함수의 호출은 로그로 시, 분, 초 확인을 위해 호출하는 것이며
호출 순서에 따라 evaluation value 변경 가능성이 없습니다.
또한 로그 찍을 때 호출되는 것이기에 return되는 값에 직접적인 영향을 주지 않습니다.

[CQA셀] 김현희 연구원
해당 부분은 fucntion call 호출로 인한 호출 순서에 따른 evaluation value 변경 가능성에 대해서 탐지된 건입니다. 서로의 함수 호출이 리턴되는 값에 서로 영향을 주지 않는지 확인이 필요해보입니다.


[인포뱅크] 조기성 연구원 (모비스 담당자 : [CCU AP SW셀] 성기영 책임)

1. 이슈로 잡힌 이유 :
nullcheck 없 할당된 메모리 사용

2. 정당화 사유 :
하기와 같이 NULL로 초기화 후 memset 사용이 되기 때문에 문제가 없는 것으로 보입니다.
정당화 요청 드리겠습니다. 감사합니다.
char *buf = NULL;

[Infobank] 김홍철 책임 (모비스 담당자 : [CCU AP SW셀] 성기영 책임)

1. 이슈로 잡힌 이유 :
null 값이 변수에 세팅되어 스트링 길이가 0이 될수있다.

2. 정당화 사유 :
resultStr 값은 SMS의 헥사 바이너리 값을 스트링으로 변환한 값으로 값안에 16진수 헥사값이 세팅됩니다. 해당값은 스트링으로 처리하지 않고 내부에서 헥사값으로 이용하게 됩니다.
Dst 변수를 세팅시 기존 사이즈의 2배+1로 NULL 초기화 하고 Src변수는 기존 사이즈+1로 초기화 후
값을 세팅하므로 문제가 발생할수 없는 코드입니다. 이에 정당화 요청 드립니다.

[CQA셀] 김현희 연구원
for문을 돌면서 strcat 수행을 반복적으로 진행하고 있기 때문에  BUFFER_SIZE에 대한 체커가 탐지된 듯 합니다. (2번 이상 수행시 BUFFER OVERFLOW 발생가능) 해당 부분을 고려하여 수정 또는 정당화 코멘트 재작성 부탁드립니다.



=======================thread

std::thread = 컴파일러의 스레드 모델 기반으로 만들어진 API
pthread = POSIX에서 스레드 생성, 동기화를 위해 만든 표준 API

pthread.h를 include 후 std::thread에서 pthread를 사용하여 조작할 수 있지만 coredump, 비정상적인 종료가될 수 있습니다.

timed_join = boost include 후 사용 가능하며 함수가 종료되지 않더라도 n초 동안 스레드 대기, n초 또한 boost의 posix_time 사용

std::this_thread::sleep_for(std::chrono::milliseconds(100)); 등으로 대체

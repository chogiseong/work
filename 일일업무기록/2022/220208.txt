=======================================커버리티 범위초과 건=======================================

[인포뱅크] 조기성 연구원 (모비스 담당자 : [CCU AP SW셀] 성기영 책임)

1. 이슈로 잡힌 이유 :
index의 범위 초과 가능성

2. 정당화 사유 :
buf의 값이 결정될 때 item[i].getLength() + 1 만큼 동적 할당되고 nLength는 buf를 사용해 length를 return하게 되어 nLength를 받았을 때 범위를 벗어날 수 없음

[CQA셀] 김현희 연구원
위에 언급된 사유에 대해서 논리적 정당성이 작성되어야 합니다. 범위를 벗어날 수 없도록 제어하는 로직에 대해서 기재 부탁드립니다.

[인포뱅크] 조기성 연구원 (모비스 담당자 : [CCU AP SW셀] 성기영 책임)

1. 이슈로 잡힌 이유 :
index의 범위 초과 가능성

2. 정당화 사유 :
index의 값이 결정되는 범위인 nApnXmlSize가 상위 로직에서 .size() -1 로 범위 지정이 되어있고, 삼항 연산자 로직에서 (nApnXmlSize < if_id) || (if_id < 0) 같이 범위 설정이 되어있기 때문에 범위를 벗어날 수 없음

[인포뱅크] 조기성 연구원 (모비스 담당자 : [CCU AP SW셀] 성기영 책임)

1. 이슈로 잡힌 이유 :
index의 범위 초과 가능성

2. 정당화 사유 :
Index를 전달받을 때 std::vector<std::string> mApnXmlList 에 동적할당 되기 때문에 범위를 벗어날 수 없음

[인포뱅크] 조기성 연구원 (모비스 담당자 : [CCU AP SW셀] 성기영 책임)

1. 이슈로 잡힌 이유 :
index의 범위 초과 가능성

2. 정당화 사유 :
attribute_names[] 값 확인, 비교를 위한 iterator 사용이며 i = 0 부터 attribute_names[i] != NULL 까지 범위가 지정되어 있기 때문에 범위를 벗어날 수 없음

=======================================커버리티 중복 함수명 건=======================================

[인포뱅크] 조기성 연구원 (모비스 담당자 : [CCU AP SW셀] 성기영 책임)

1. 이슈로 잡힌 이유 :
동일한 함수명 중복 정의

2. 정당화 사유 :
서로 다른 모듈, 향지에서 사용하는 함수이며 각 함수가 사용되는 Process가 다릅니다.
서로 include 하지 않기에 해당 함수가 중복되어 정의되어 있는것이 아니며 정상 동작합니다. 정당화 요청 드리겠습니다.

=======================================커버리티 ENUM 클래스 예약어 인식 건=======================================

[인포뱅크] 조기성 연구원 (모비스 담당자 : [CCU AP SW셀] 김석환 책임)

1. 이슈로 잡힌 이유 :
예약 식별자 바인드 선언 또는 정의

2. 정당화 사유 :
예약 식별자로 인식된 enum은 헤더 tmdb namespace 내에서 enum으로 등록하어 구분되기 때문에 예약 식별자가 아닙니다.

[인포뱅크] 조기성 연구원 (모비스 담당자 : [CCU AP SW셀] 성기영 책임)

1. 이슈로 잡힌 이유 :
예약 식별자 선언 또는 정의

2. 정당화 사유 :
헤더 namespace json 내에 선언되어 분리 동작하기 때문에 예약 식별자와 구분되며 동작상 문제가 없습니다. 정당화 요청 드리겠습니다.


[인포뱅크] 조기성 연구원 (모비스 담당자 : [CCU AP SW셀] 성기영 책임)

1. 이슈로 잡힌 이유 작성
프로그램 강제로 종료시키는 시스템 abort() 함수가 실행.

2. 정당화 사유 :
해당 abort 코드는 오픈 소스 jsoncpp 내부 코드이며 반드시 필요한 파라미터 값에 심각한 문제가 있어 정상적인 수행이 불가한 경우에만 실행되는 코드입니다.
현재 사용 가이드에 맞게 사용하여 해당 문제점이 발생되지 않게 모두 적용된 상태입니다. 정당화 요청 드리겠습니다.

=======================================커버리티 예약어 인식 건=======================================

[인포뱅크] 조기성 연구원 (모비스 담당자 : [CCU AP SW셀] 성기영 책임)

1. 이슈로 잡힌 이유 :
예약 식별자 선언 또는 정의

2. 정당화 사유 :
해당 api를 호출하는 부분 모두 json namespace 통해서 std 라이브러리와 별도로 분리 동작되는 것 확인했습니다. 정당화 요청 드리겠습니다.

클래스의 멤버변수로

[인포뱅크] 조기성 연구원 (모비스 담당자 : [CCU AP SW셀] 성기영 책임)

1. 이슈로 잡힌 이유 :
동일한 심볼명 중복 정의

2. 정당화 사유 :
서로 다른 모듈 또는 향지에서 사용하는 심볼이며 각각 사용되는 Process가 다릅니다.
서로 include 하지 않기에 해당 심볼이 중복되어 정의되어 있는것이 아니며 정상 동작합니다. 정당화 요청 드리겠습니다.



[인포뱅크] 조기성 연구원 (모비스 담당자 : [CCU AP SW셀] 성기영 책임)

1. 이슈로 잡힌 이유 :
index의 범위 초과 가능성

2. 정당화 사유 :
buf의 범위가 item[i].getLength() + 1 만큼의 동적 할당되며, buf에 넣어지는 nLength의 값 자체가 buf를 사용하는 함수 parseHexString을 통해서 return 됩니다.
그렇기 때문에 nLength를 buf에 넣었을 때 범위를 초과할 가능성이 없으며 정상 동작됩니다. 정당화 요청 드리겠습니다.

[CQA셀] 김현희 연구원
parseHexString 에서의 return 값이 첫번째 argument에 해당하고, 배열 접근은 두번째 argument 값에 대해서 이루어 지고 있습니다 .이는 서로 다른 배열로 재확인이 필요해보입니다.

[인포뱅크] 조기성 연구원 (모비스 담당자 : [CCU AP SW셀] 성기영 책임)

1. 이슈로 잡힌 이유 :
index의 범위 초과 가능성

2. 정당화 사유 :
attribute_names를 통해 attribute_values를 얻어 해당 기능을 수행하는 함수이며 attribute_names에 i가 NULL이 아닐때 까지 반복하게 되고 NULL이 아닐 시 해당 기능 수행
, NULL일 시 계속 반복하여 찾는 코드입니다.

[CQA셀] 김현희 연구원
일단 NULL이 나올때까지 배열 index에 접근하는데 실제 배열이 어디서 끝나는지가 확인이 되지 않는 배열에서의 접근은 overflow 가능성이 있어보입니다. 재확인을 부탁드립니다.

=======================================커버리티 인덱스 범위건=======================================

[인포뱅크] 조기성 연구원 (모비스 담당자 : [CCU AP SW셀] 성기영 책임)

1. 이슈로 잡힌 이유 :
index의 범위 초과 가능성

2. 정당화 사유 :
attribute_names != NULL 확인,
하기와 같이 i의 범위 추가 후 정상 동작 확인했습니다. 정당화 요청 드리겠습니다.
std::string strlength = std::string((char*)attribute_names);
for (i = 0; (i < strlength.length()) && (attribute_names[i] != NULL); i++)

=======================================커버리티 json 제외 건=======================================

[인포뱅크] 조기성 연구원 (모비스 담당자 : [CCU AP SW셀] 성기영 책임)

1. 이슈로 잡힌 이유 :
json 관련 이슈

2. 정당화 사유 :
제외 경로 처리 요청했으나 필터링 미반영된 것으로 보여집니다.
정당화 요청 드리겠습니다.

=======================================커버리티 json 제외 건=======================================

[인포뱅크] 조기성 연구원 (모비스 담당자 : [CCU AP SW셀] 성기영 책임)

1. 이슈로 잡힌 이유 :
getValue 호출에서 잡히지 않는 예외 발생 이슈

2. 정당화 사유 :
하기와 같이 예외처리 코드 추가했습니다.
정당화 요청 드리겠습니다.
try{mpHSystemInfo->getValue ("GENERAL_REGION", value);}
catch (const std::exception& e){MSG_ERROR("%s", e.what());}

[인포뱅크] 조기성 연구원 (모비스 담당자 : [CCU AP SW셀] 성기영 책임)

1. 이슈로 잡힌 이유 :
평가 순서가 정해지지 않은 인수에 다수의 변수 호출

2. 정당화 사유 :
하기와 같이 인자에 맞게 변수 수정 진행했습니다.
정당화 요청 드리겠습니다.
MSG_LOW("mpHClock hour[%u], minute[%u], second[%u]", htime.getHour(), htime.getMinute(), htime.getSecond());



[인포뱅크] 조기성 연구원 (모비스 담당자 : [CCU AP SW셀] 성기영 책임)

1. 이슈로 잡힌 이유 :
start() 함수내에서 생성하는 Thread 객체의 소멸자 호출 시 joinable() 조건이 TRUE일 경우 std::terminate() 호출 가능성

2. 정당화 사유 :
Thread 생성 직후 detach()를 하기 때문에 joinable() 조건은 FALSE가 되어 std::terminate()가 호출 될 수 없습니다. 정당화 요청 드리겠습니다.

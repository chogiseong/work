1. 빌드 루틴

    CE1_28 빌드완료
    CE1_master 빌드완료

2. 코드 분석 및 모르는 부분 탐색

=====================================================================================================================================================

2. 재귀함수 - 반복문을 통한 구현은 i변수 사용, result는 어디에 사용되는지 등 직접해석해야 하지만 재귀함수를 사용하면 해당 알고리즘 논리를 바로 코드로 전환 가능(가독성이 있다.)

  함수 내에서 자기 자신을 다시 return해가며 전달받은 값을 -1 해서 특정 상황에 달했을때 return 을 선언 해주면 구현 가능

3. map - list, vector보다 탐색 속도가 빠름(이진트리) 단점은 자동정렬, 해쉬맵이 아니라는 점 키값 쌍이며 이터레이터(반복자) 사용

  map 선언 시 < 키 자료형, 밸류 자료형 > 쓰고 맵이름.insert(make_pair(키값, 밸류)), 맵이름[키값] = 밸류 둘다 가능
  맵이름.erase(키값), 맵이름.erase(맵이름.find(키값)) 둘다 가능
  맵이름.empty() 이건 bool 이라 !맵이름.empty() 등 사용 가능 ex) if(!m.empty()) cout << "m size: " << m.size() << '\n';
  키값을 통해 맵이름.find로 찾을 수 있고 맵이름.count로 키값에 해당하는 원소 갯수를 반환할 수 있음
  begin, end
  for(auto it = m.begin(); it != m.end(); it++){
		cout << "key: " << it->first << " " << "value: " << it->second << '\n';
	}
  키값 쌍이기 때문에 auto 사용
  위처럼 키값을 갖고오고 싶으면 탐색에 사용되는 변수 이터레이터 ->first 밸류를 갖고오고 싶으면 ->second 이런식으로 사용해야함

3-1. unordered_map map보다 빠른 탐색 가능 해쉬테이블로 구현되었으며 시간복잡도는 O(1)

  중복된 데이터를 허용하지 않고 map에 비해 데이터 많을 시 월등히 좋은 성능
  key가 유사하다면 해시 충돌로 성능 저하 가능

4. return 함수의 실행을 끝낸다. void에서는 반환 값 없이 단독으로 사용. void ex) return; normal ex) return 반환값;

  함수 실행 도중 강제로 수행 종료 가능

5. call by value

  값을 복사해 인자로 전달 복사된 인자는 값이 변해도 외부 변수 값은 변하지 않음 ex) void func_by_value(int a, int b)

6. call by reference

  호출 시 인자로 전달되는 변수의 레퍼런스를 전달하여 인자 값 변경 시 외부 변수 값도 변 ex) void func_by_reference(int & a, int & b)

7. 스마트 포인터 smart pointer

  new 로 동적할당했다면 delete로 해제해야 한다. 스마트포인터는 사용이 끝난 메모리를 자동 해제 해준다.

8. 유니크, 쉐어드 포인터

  메모리 사용 후 해제하지 않는 경우 memory leak 발생, 해제된 메모리를 다시 참조하는 경우(두번해제하는 double free 버그 등)
  이와 같은 버그는 소유권이 명확하지 않아서 발생.
  이 포인터 외에는 객체 소멸을 시킬 수 없다 라는게 유니크포인터. ex) delete data 는 가능, delete data2 는 불가능
  std::unique_ptr<A> pa(new A()); == A* pa = new A();
  pa->some(); 이런식으로 포인터처럼 사용하면 된다.

9. try, throw, catch

  예외처리 구문으로 try는 예외가 발생할 가능성 있는 코드를, throw는 발생한 오류에 대한 정보를 전달, catch는 그 예외에 대해 핸들러가 처리할 내용을 담은 코드

10. 스레드풀

  스레드를 보관하는 벡터(동적할당배열) worker들이 돌아갈거고 어떻게 저장하냐 하면
  스레드 수를 알 수 있을 벡터 크기 저장한 변수, 소비자 생산자 패턴 구현을 위한뮤텍스, condition_variable 스레드 종료를위한 bool

  ThreadPool::ThreadPool 선언 시 벡터 크기만큼 스레드 생성, threadPool에 정의된 workerthread 함수 실행.
  .wait으로 자기 자신을 받아서 .empty() 해봤을때 stop_all

  worker thread, threadpool에

=====================================================================================================================================================

3. FileSecuritySingle 분석

  encryptFile type, inPutFile, outPutFile 받아서
  try 만약 keyPath가 비어있으면 mkeyPath에 KEY_PATH < #define KEY_PATH "/appdata/.tele/sec_db/.encryption.key" > 하드코딩을 넣고
  비어있지 않으면 걍 실행
  메세지 넣고
  access 해보고 F_OK

  R_OK: 읽기 권한 확인
  W_OK: 쓰기 권한 확인
  X_OK: 실행 권한 확인
  F_OK: 파일 존재 여부 확인

  파일도 없고 generateKey(mkeypath) 이게 부울인것같은데 키생성하는 것 같음 / 파일도 없고 키생성도 못하면
  security exception 걸고 fail generate key , throw exceptionNum
  등등 있고
  catch로 만약 fail이면 로그 출력하게끔 설계해놨음.
  이거 전부 안걸리면
  success.
  이런식으로 디크립트(복호화)도 구현되어있음

4. RCSDoorLockUnlockService 분석

bool RCSDoorLockUnlockServiceBase::isNeedEvent(HANDLE_E_DATA_T eventData)

eventType의 HANDLE_E_DATA를 참조하여 nEvent가 해당 이넘과 같다면 true 아닐 시 false

void RCSDoorLockUnlockServiceBase::checkEventAndPush(HANDLE_E_DATA_T eventData)

isNeedEvent가 true값 반환 시 이넘 handlerunstate svcstate 에 mRunstate를 넣고 스테이트 로그 출력, addEvent (addevent는 뮤텍스 유니크 록 후 emplace_back, notify 스레드할당) 이벤트 이름과 기능을 넣음

handleEvent로 상황에 맞게 case 핸들링



조기성
윈도우 IPv4 주소 : 10.238.7.152
